from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import tensorflow as tf
from tensorflow.keras import layers, models, applications
import numpy as np
import pickle
import os
from PIL import Image
import io
from sklearn.preprocessing import LabelEncoder

app = FastAPI()

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with your frontend domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/templates", StaticFiles(directory="templates"), name="templates")

# Define age groups
AGE_GROUPS = {
    '01_Child': (1, 17),
    '02_YoungAdult': (18, 35),
    '03_MiddleAge': (36, 55),
    '04_Senior': (56, 100)
}

# Load models at startup
@app.on_event("startup")
async def load_models():
    global feature_extractor, feature_adapter, generalist_model, specialist_model, label_encoder
    
    try:
        print("Loading models...")
        # Create feature extractor
        feature_extractor = applications.EfficientNetV2B0(
            weights='imagenet',
            include_top=False,
            input_shape=(224, 224, 3)
        )
        feature_extractor.trainable = False
        
        # Create feature adapter layer to match expected input size
        feature_adapter = tf.keras.Sequential([
            layers.GlobalAveragePooling2D(),
            layers.Dense(2622, activation='relu', name='feature_adapter')
        ])
        print("✅ Feature extractor and adapter created")
        
        # Load the best Generalist model
        generalist_model = tf.keras.models.load_model('models/best_generalist_model.h5')
        print("✅ Best Generalist model loaded")
        
        # Create and fit Label Encoder with age group labels in order
        label_encoder = LabelEncoder()
        label_encoder.fit(sorted(AGE_GROUPS.keys()))
        print("✅ Label encoder created")
        
        # Load the best Specialist model
        specialist_model = tf.keras.models.load_model('models/best_specialist_model.h5')
        print("✅ Best Specialist model loaded")
        
    except Exception as e:
        print(f"❌ Error loading models: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error loading models: {str(e)}")

def preprocess_image(image_bytes):
    """Preprocess image bytes for model input"""
    try:
        # Open image from bytes
        img = Image.open(io.BytesIO(image_bytes))
        
        # Convert to RGB if necessary
        if img.mode != 'RGB':
            img = img.convert('RGB')
        
        # Resize to model's expected size
        img = img.resize((224, 224))
        
        # Convert to array and preprocess
        img_array = tf.keras.preprocessing.image.img_to_array(img)
        img_array = np.expand_dims(img_array, 0)
        img_array = img_array / 255.0  # Normalize to [0, 1]
        
        return img_array
    
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error processing image: {str(e)}")

@app.get("/", response_class=HTMLResponse)
async def read_root():
    """Serve the main HTML page"""
    with open("templates/index.html", encoding='utf-8') as f:
        return HTMLResponse(content=f.read(), status_code=200)

@app.post("/predict-age/")
async def predict_age(image: UploadFile = File(...)):
    """
    Three-step age prediction process:
    1. Extract facial features using VGG-Face
    2. Predict age group using Generalist model
    3. Predict precise age using Specialist model
    """
    try:
        try:
        try:
            # Read and preprocess the image
            contents = await image.read()
            processed_image = preprocess_image(contents)
            
            print("\nExtracting features...")
            # Step 1: Extract features using EfficientNetV2B0 and adapt them
            base_features = feature_extractor(processed_image, training=False)
            print("Base features stats:", {
                "shape": base_features.shape,
                "mean": float(tf.reduce_mean(base_features)),
                "std": float(tf.math.reduce_std(base_features))
            })
        except Exception as e:
            print(f"Error during feature extraction: {str(e)}")
            raise HTTPException(status_code=500, detail=f"Feature extraction error: {str(e)}")        features = feature_adapter(base_features, training=False)
        print("Adapted features stats:", {
            "shape": features.shape,
            "mean": float(tf.reduce_mean(features)),
            "std": float(tf.math.reduce_std(features)),
            "min": float(tf.reduce_min(features)),
            "max": float(tf.reduce_max(features))
        })
        
        print("\nMaking generalist model prediction...")
        # Step 2: Get age range prediction from generalist model
        range_prediction = generalist_model(features, training=False)
        print("Range prediction details:", {
            "shape": range_prediction.shape,
            "values": range_prediction.numpy().tolist(),
            "predicted_class": int(tf.argmax(range_prediction[0])),
            "confidence": float(tf.reduce_max(range_prediction[0]))
        })
        
        predicted_range_idx = np.argmax(range_prediction[0])
        print("Predicted range index:", predicted_range_idx)
        
        predicted_range = label_encoder.inverse_transform([predicted_range_idx])[0]
        print("Predicted range:", predicted_range)
        
        # Get age range bounds
        min_age, max_age = AGE_GROUPS[predicted_range]
        print(f"Age range bounds: {min_age}-{max_age}")
        
        print("Making specialist model prediction...")
        # Step 3: Get specific age prediction from specialist model
        # Create age group one-hot encoding
        age_group_one_hot = tf.keras.utils.to_categorical([predicted_range_idx], num_classes=len(AGE_GROUPS))
        print("Age group one-hot shape:", age_group_one_hot.shape)
        
        # Create model inputs
        specialist_inputs = [features, age_group_one_hot]
        age_prediction = specialist_model(specialist_inputs, training=False)
        print("Age prediction shape:", age_prediction.shape)
        print("Age prediction values:", age_prediction)
        
        try:
            print("\nDetailed prediction analysis:")
            
            # 1. Analyze generalist model predictions
            print("1. Range Prediction Details:")
            group_probs = range_prediction[0].numpy()
            sorted_indices = np.argsort(group_probs)[::-1]
            for idx in sorted_indices:
                group = label_encoder.inverse_transform([idx])[0]
                prob = group_probs[idx]
                print(f"  {group}: {prob*100:.2f}% confidence")
            
            # 2. Analyze specialist model output
            print("\n2. Specialist Model Details:")
            raw_output = float(age_prediction[0][0])
            print(f"  Raw output: {raw_output}")
            
            # 3. Calculate final age prediction
            print("\n3. Age Calculation:")
            
            # Get the selected age range
            group_min, group_max = AGE_GROUPS[predicted_range]
            age_range = group_max - group_min
            print(f"  Selected age range: {predicted_range} ({group_min}-{group_max})")
            
            # Convert raw output to relative position using tanh
            # tanh maps any number to [-1, 1], so (tanh + 1) / 2 maps to [0, 1]
            relative_position = (tf.tanh(raw_output).numpy() + 1) / 2
            print(f"  Relative position in range: {relative_position:.4f}")
            
            # Calculate age by interpolating within the range
            predicted_age = group_min + (age_range * relative_position)
            predicted_age = round(predicted_age)
            
            # Ensure the prediction stays within the valid range
            predicted_age = np.clip(predicted_age, group_min, group_max)
            print(f"  Final predicted age: {predicted_age}")
            print(f"Final predicted age: {predicted_age}")
            
            confidence = float(range_prediction[0][predicted_range_idx]) * 100  # Convert to percentage
            
            print(f"Final prediction: Age {predicted_age}, Group {predicted_range}, Confidence {confidence}%")
            
            if np.isnan(predicted_age) or np.isnan(confidence):
                raise ValueError("Prediction resulted in NaN values")
            
            return JSONResponse({
                'age_group': predicted_range,
                'predicted_age': predicted_age,
                'confidence': confidence
            })
        except Exception as e:
            print(f"Error in final prediction step: {str(e)}")
            print(f"age_prediction value: {age_prediction[0][0]}")
            print(f"min_age: {min_age}, max_age: {max_age}")
            print(f"range_prediction: {range_prediction[0]}")
            raise HTTPException(
                status_code=500, 
                detail=f"Error calculating final prediction: {str(e)}"
            )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Prediction error: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8002)  # Changed port to 8002